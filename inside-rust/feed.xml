<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/inside-rust/" version="0.1.0">Inside Rust Blog</generator>
    <link href="https://blog.rust-lang.org/inside-rust/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/inside-rust/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/inside-rust/</id>
    <title>Inside Rust Blog</title>
    <subtitle>Want to follow along with Rust development? Curious how you might get involved? Take a look!</subtitle>
    <author>
        <name>Maintained by the Rust Teams.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2023-05-30T10:00:33+00:00</updated>

    
    <entry>
        <title>1.70.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/05/29/1.70.0-prerelease.html" type="text/html" title="1.70.0 pre-release testing" />
        <published>2023-05-29T00:00:00+00:00</published>
        <updated>2023-05-29T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/05/29/1.70.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/05/29/1.70.0-prerelease.html">&lt;p&gt;The 1.70.0 pre-release is ready for testing. The release is scheduled for
June 1. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1700-2023-06-01&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2023-05-29/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2023-05-29/index.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-70-0-pre-release-testing/18904&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The release team is also thinking about changes to our pre-release process:
we&#x27;d love your feedback &lt;a href&#x3D;&quot;https://github.com/rust-lang/release-team/issues/16&quot;&gt;on this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Release automation</name>
        </author>
    </entry>
    
    <entry>
        <title>API token scopes</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/05/09/api-token-scopes.html" type="text/html" title="API token scopes" />
        <published>2023-05-09T00:00:00+00:00</published>
        <updated>2023-05-09T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/05/09/api-token-scopes.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/05/09/api-token-scopes.html">&lt;p&gt;Roughly three years ago &lt;a href&#x3D;&quot;https://github.com/pietroalbini&quot;&gt;Pietro Albini&lt;/a&gt; opened an RFC called &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/2947&quot;&gt;&amp;quot;crates.io token scopes&amp;quot;&lt;/a&gt;. This RFC described an improvement to the existing API tokens, that everyone is using to publish crates to the &lt;a href&#x3D;&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; package registry. The proposal was to make it possible to restrict API tokens to 1) certain operations and 2) certain crates.&lt;/p&gt;
&lt;p&gt;Unfortunately, the crates.io team members were quite busy at the time, so it took a while for this proposal to get accepted. To be precise, during the &lt;a href&#x3D;&quot;https://eurorust.eu&quot;&gt;EuroRust&lt;/a&gt; conference in October 2022 we talked about the RFC again and after a few modifications the RFC was moved into FCP status and then finally merged.&lt;/p&gt;
&lt;p&gt;The implementation was started soon after, but was paused again due to other priorities at the time. Fortunately, I was lucky enough to get one of the software engineering jobs at the &lt;a href&#x3D;&quot;https://rustfoundation.org/&quot;&gt;Rust Foundation&lt;/a&gt;, so in early April the development continued, and I am happy to report:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;API token scopes on crates.io are now in a public beta testing period!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For details on what these token scopes are and how they are supposed to work, I recommend reading through the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/2947&quot;&gt;RFC&lt;/a&gt;. If you want to try them out, you can go to &lt;a href&#x3D;&quot;https://crates.io/settings/tokens/new&quot;&gt;https://crates.io/settings/tokens/new&lt;/a&gt; and create a new API token scoped to the operations and crates you want:&lt;/p&gt;
&lt;p&gt;&lt;img src&#x3D;&quot;../../../../images/inside-rust/2023-05-09-api-token-scopes/screenshot.png&quot; alt&#x3D;&quot;Screenshot of the &amp;quot;New API Token&amp;quot; page&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Please note that this page is currently not reachable from the regular user interface, you have to access it via URL directly while we test it out.&lt;/p&gt;
&lt;p&gt;Finally, if you notice any issues, or if you have any questions don&#x27;t hesitate to find us on &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/318791-t-crates-io/topic/token.20scopes&quot;&gt;Zulip&lt;/a&gt; or open an issue on &lt;a href&#x3D;&quot;https://github.com/rust-lang/crates.io/issues/new/choose&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Tobias Bieniek</name>
        </author>
    </entry>
    
    <entry>
        <title>Stabilizing async fn in traits in 2023</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/05/03/stabilizing-async-fn-in-trait.html" type="text/html" title="Stabilizing async fn in traits in 2023" />
        <published>2023-05-03T00:00:00+00:00</published>
        <updated>2023-05-03T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/05/03/stabilizing-async-fn-in-trait.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/05/03/stabilizing-async-fn-in-trait.html">&lt;p&gt;The async working group&#x27;s headline goal for 2023 is to stabilize a &amp;quot;minimum viable product&amp;quot; (MVP) version of async functions in traits. We are currently targeting Rust 1.74 for stabilization. This post lays out the features we plan to ship and the status of each one.&lt;/p&gt;
&lt;p&gt;In November, we &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly.html&quot;&gt;blogged about nightly support for async fn in trait&lt;/a&gt; and identified some key next steps, most importantly &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly.html#limitation-spawning-from-generics&quot;&gt;support for send bounds to allow spawning in generic functions&lt;/a&gt;. Since then we&#x27;ve done a significant amount of design exploration and collected a set of case studies evaluating how well the current code works in practice.&lt;/p&gt;
&lt;p&gt;As of now, all of the functionality described in this blog post is available on the nightly compiler. Some of this work was implemented using &lt;a href&#x3D;&quot;https://lang-team.rust-lang.org/how_to/experiment.html&quot;&gt;experimental feature gates&lt;/a&gt; so that we could conduct case studies and prove out viability; we are in the process of authoring RFCs for those features now (full details below).&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#mvp-part-1-core-support-for-async-functions-in-traits&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;mvp-part-1-core-support-for-async-functions-in-traits&quot;&gt;&lt;/a&gt;MVP Part 1: Core support for &amp;quot;async functions in traits&amp;quot;&lt;/h2&gt;
&lt;p&gt;The easiest way to explain what we are going to stabilize is to use a code example. To start, we will permit the use of &lt;code&gt;async fn&lt;/code&gt; in trait definitions...&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait HealthCheck {
    async fn check(&amp;amp;mut self) -&amp;gt; bool;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;...and you can then use &lt;code&gt;async fn&lt;/code&gt; in the corresponding impl:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;impl HealthCheck for MyHealthChecker {
    async fn check(&amp;amp;mut self) -&amp;gt; bool {
        do_async_op().await
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Traits with async functions can then be used as you normally would:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;async fn do_health_check(hc: impl HealthCheck) {
    if !hc.check().await {
        log_health_check_failure().await;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Status:&lt;/strong&gt; This functionality was described in &lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/3185-static-async-fn-in-trait.html&quot;&gt;RFC 3185&lt;/a&gt;, merged on Dec 7, 2021, and is available in nightly. It was covered in detail in our &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly.html&quot;&gt;previous blog post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;nightly&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;2399715f67d8eb0064efd6c8e47532f7&quot;&gt;Playground&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#mvp-part-2-send-bounds-and-associated-return-types&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;mvp-part-2-send-bounds-and-associated-return-types&quot;&gt;&lt;/a&gt;MVP Part 2: Send bounds and associated return types&lt;/h2&gt;
&lt;p&gt;There is one complication that arises when using async functions in traits that doesn&#x27;t arise with sync functions. Many async runtimes -- notably including the default configurations of &lt;a href&#x3D;&quot;https://tokio.rs/&quot;&gt;Tokio&lt;/a&gt; and &lt;a href&#x3D;&quot;https://async.rs/&quot;&gt;async-std&lt;/a&gt; -- use a work stealing thread scheduler. This means that futures may move between worker threads dynamically to achieve load balancing. As a result, the future must only capture &lt;code&gt;Send&lt;/code&gt; data.&lt;/p&gt;
&lt;p&gt;If you author a generic async function that spawns tasks on one of those runtimes, however, you will start to get compilation errors (&lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;nightly&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;c033cf6174ff7d44e5673ecd254e6e69&quot;&gt;playground&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;async fn do_health_check_par(hc: impl HealthCheck) {
    tokio::task::spawn(async move {
        if !hc.check().await {
            log_health_check_failure().await;
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The problem is that the future returned by &lt;code&gt;hc.check()&lt;/code&gt; isn&#x27;t guaranteed to be &lt;code&gt;Send&lt;/code&gt;. It might access non-Send data. The solution is to add a &lt;code&gt;Send&lt;/code&gt; bound, but given that this is an async function, it&#x27;s not obvious how to do that. How do we talk about the future returned by a call to &lt;code&gt;hc.check()&lt;/code&gt;? Associated return types provide the answer. We can convert the above function to use an explicit type parameter &lt;code&gt;HC&lt;/code&gt; (instead of &lt;code&gt;impl HealthCheck&lt;/code&gt;) and then add a new bound, &lt;code&gt;HC::check(): Send&lt;/code&gt;. This says &amp;quot;the value returned by &lt;code&gt;HC::check&lt;/code&gt; must be of &lt;code&gt;Send&lt;/code&gt; type&amp;quot;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;async fn do_health_check_par&amp;lt;HC&amp;gt;(hc: HC)
where
    HC: HealthCheck + Send + &#x27;static,
    HC::check(): Send, // &amp;lt;-- associated return type
{
    tokio::task::spawn(async move {
        if !hc.check().await {
            log_health_check_failure().await;
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, it&#x27;s kind of unfortunate that we had to rewrite from taking an &lt;code&gt;impl HealthCheck&lt;/code&gt; to an explicit &lt;code&gt;HC&lt;/code&gt; type parameter in order to use this notation. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/2289&quot;&gt;RFC 2289&lt;/a&gt;, &amp;quot;associated type bounds&amp;quot;, introduced a compact notation to address this problem. That RFC is not part of this MVP, but if it were stabilized, then one could simply write:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;async fn do_health_check_par(hc: impl HealthCheck&amp;lt;check(): Send&amp;gt; + Send + &#x27;static) {
    //                                            -------------
    tokio::task::spawn(async move {
        if !hc.check().await {
            log_health_check_failure().await;
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In our &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly.html&quot;&gt;previous post&lt;/a&gt;, we &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly.html#hypothesis-this-is-uncommon&quot;&gt;hypothesized&lt;/a&gt; that this problem might not occur often in practice. However, our case studies found that it comes up quite frequently, and so we decided that a solution is needed. We explored a number of solutions and concluded that associated return types (ARTs) are a flexible and reasonably ergonomic building block, which makes them a great fit for an MVP.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Status:&lt;/strong&gt; Associated return types have an experimental implementation and we are currently drafting an RFC. There are several open bugs that will need to be fixed. We also found that in traits with many methods, ARTs become verbose, and in the future may consider more concise syntax (see below).&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;nightly&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;2066934a05cb9eafc0b47af7bdf8c57f&quot;&gt;Playground&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#mvp-part-3-impl-trait-in-traits-return-position&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;mvp-part-3-impl-trait-in-traits-return-position&quot;&gt;&lt;/a&gt;MVP Part 3: &amp;quot;impl trait in traits&amp;quot; (return position)&lt;/h2&gt;
&lt;p&gt;In Rust an async function is &amp;quot;syntactic sugar&amp;quot; for a function that returns an &lt;code&gt;impl Future&lt;/code&gt;, and async functions in traits are no exception. As part of the MVP, we plan to stabilize the use of &lt;code&gt;-&amp;gt; impl Trait&lt;/code&gt; notation in traits and trait impls.&lt;/p&gt;
&lt;p&gt;Impl trait in traits has all kinds of uses, but one common one for async programming is to avoid capturing all of the function arguments by doing some amount of sync work and then returning a future for the rest. For example, this &lt;code&gt;LaunchService&lt;/code&gt; trait declares a &lt;code&gt;launch&lt;/code&gt; function that does not capture &lt;code&gt;self&lt;/code&gt; (similar to the existing Tower &lt;a href&#x3D;&quot;https://docs.rs/tower/latest/tower/trait.Service.html&quot;&gt;&lt;code&gt;Service&lt;/code&gt;&lt;/a&gt; trait):&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait LaunchService {
    fn launch(
        &amp;amp;mut self, 
        request: Request,
    ) -&amp;gt; impl Future&amp;lt;Output &#x3D; u32&amp;gt;;
    //   -------------------------
    //   Does not capture &#x60;self&#x60; as it does
    //   not include a &#x60;+ &#x27;_&#x60;.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since &lt;code&gt;async fn&lt;/code&gt; is sugar for a regular function returning &lt;code&gt;impl Future&lt;/code&gt;, these two syntactic forms will work interchangeably.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait HealthCheck {
    async fn check(&amp;amp;mut self) -&amp;gt; bool;
}

impl HealthCheck for MyType {
    fn check(&amp;amp;mut self) -&amp;gt; impl Future&amp;lt;Output &#x3D; bool&amp;gt; + &#x27;_ { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Even though the need for &amp;quot;impl trait in traits&amp;quot; comes up a lot in async, they are a general feature that will be useful in many contexts having nothing to do with async (for example, returning iterators from trait methods).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Status:&lt;/strong&gt; Return-position impl trait in traits have an experimental implementation and are described in &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/3425&quot;&gt;RFC 3425&lt;/a&gt;, which is currently open. This feature can stand on its own, but is an important part of the picture for &lt;code&gt;async fn&lt;/code&gt; in traits.&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;nightly&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;75cfc199cc50a111576c2d8e342ae823&quot;&gt;Playground&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#evaluating-the-mvp&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;evaluating-the-mvp&quot;&gt;&lt;/a&gt;Evaluating the MVP&lt;/h2&gt;
&lt;p&gt;To evaluate the utility of this MVP, the working group collected &lt;a href&#x3D;&quot;https://rust-lang.github.io/async-fundamentals-initiative/evaluation/case-studies.html&quot;&gt;five case studies&lt;/a&gt; covering the &lt;a href&#x3D;&quot;https://rust-lang.github.io/async-fundamentals-initiative/evaluation/case-studies/builder-provider-api.html#dynamic-dispatch-behind-the-api&quot;&gt;builder-provider pattern used in the AWS SDK&lt;/a&gt;; the potential use of async function in traits in &lt;a href&#x3D;&quot;https://rust-lang.github.io/async-fundamentals-initiative/evaluation/case-studies/tower.html&quot;&gt;tower&lt;/a&gt; and the actual use in &lt;a href&#x3D;&quot;https://rust-lang.github.io/async-fundamentals-initiative/evaluation/case-studies/embassy.html&quot;&gt;embassy&lt;/a&gt;, the &lt;a href&#x3D;&quot;https://rust-lang.github.io/async-fundamentals-initiative/evaluation/case-studies/socket-handler.html&quot;&gt;Fuchsia networking stack&lt;/a&gt; and &lt;a href&#x3D;&quot;https://rust-lang.github.io/async-fundamentals-initiative/evaluation/case-studies/microsoft.html&quot;&gt;an internal Microsoft tool&lt;/a&gt;. These studies validated that the above functionality is sufficient to use async function in traits for all kinds of things, though some situations require workarounds (hence the &amp;quot;MVP&amp;quot; title).&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-the-mvp-will-not-support-or-wont-support-well&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-the-mvp-will-not-support-or-wont-support-well&quot;&gt;&lt;/a&gt;What the MVP will not support or won&#x27;t support well&lt;/h2&gt;
&lt;p&gt;The case studies revealed two situations that the MVP doesn&#x27;t support very well, but both of them have workarounds available. These workarounds are mechanical and once the MVP is available on stable it will be possible to automate them via a custom derive or other crates on crates.io.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#modeling-dynamic-dispatch&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;modeling-dynamic-dispatch&quot;&gt;&lt;/a&gt;Modeling dynamic dispatch&lt;/h3&gt;
&lt;p&gt;In the MVP, traits that use async functions are not &amp;quot;dyn safe&amp;quot;, meaning that they don&#x27;t support dynamic dispatch. So e.g. given the &lt;code&gt;HealthCheck&lt;/code&gt; trait we saw earlier, one could not write &lt;code&gt;Box&amp;lt;dyn HealthCheck&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;At first, this seems like a crucial limitation, since many of the use cases require dynamic dispatch! But it turns out that there is a workaround. One can define an &amp;quot;erased&amp;quot; trait internally to your crate that enables dynamic dispatch. The process was pioneered by crates like &lt;a href&#x3D;&quot;https://github.com/dtolnay/erased-serde&quot;&gt;erased serde&lt;/a&gt; and is explained in detail in the &lt;a href&#x3D;&quot;https://rust-lang.github.io/async-fundamentals-initiative/evaluation/case-studies/builder-provider-api.html#dynamic-dispatch-behind-the-api&quot;&gt;builder-provider case study&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To make this workaround easier in the near term, we plan to provide a proc macro to automate it. In the future, async fn &lt;a href&#x3D;&quot;https://rust-lang.github.io/async-fundamentals-initiative/explainer/user_guide_future.html#dynamic-dispatch-and-async-functions&quot;&gt;should work&lt;/a&gt; with &lt;code&gt;dyn Trait&lt;/code&gt; directly.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#send-bounds-are-verbose-especially-for-traits-with-lots-of-methods&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;send-bounds-are-verbose-especially-for-traits-with-lots-of-methods&quot;&gt;&lt;/a&gt;Send bounds are verbose, especially for traits with lots of methods&lt;/h3&gt;
&lt;p&gt;The associated return type proposal works great for traits with a single method, but it can be annoying for traits that have lots of methods. One convenient solution is to use the &amp;quot;trait alias pattern&amp;quot;:&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait SendHealthCheck
where
    Self: HealthCheck + Send,
    Self::check(): Send,
{}

impl&amp;lt;T&amp;gt; SendHealthCheck for T
where
    T: HealthCheck + Send,
    T::check(): Send,
{}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using a pattern like this means you can write &lt;code&gt;T: SendHealthCheck&lt;/code&gt;. We plan to provide a proc macro to write these trait aliases for you, so you can write something more like this instead:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#[make_alias(Send &#x3D; &amp;quot;SendHealthCheck&amp;quot;)]
trait HealthCheck {
    async fn check(&amp;amp;mut self) -&amp;gt; bool;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the future, something like &lt;a href&#x3D;&quot;https://smallcultfollowing.com/babysteps/blog/2023/03/03/trait-transformers-send-bounds-part-3/&quot;&gt;trait transformers&lt;/a&gt; may provide a more concise syntax without a proc macro. But because there are use cases that require the kind of fine-grained control provided by associated return types, we opted to stabilize them first and consider more concise syntaxes after gaining experience.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#timeline-and-roadmap&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;timeline-and-roadmap&quot;&gt;&lt;/a&gt;Timeline and roadmap&lt;/h2&gt;
&lt;p&gt;Our goal is to stabilize the MVP for Rust 1.74, which will be released on 2023-11-16. The branch window for this feature opens on July 14 and closes on August 24. To actually stabilize in 1.74, we want to leave room for bug fixes that may arise before the release branch is cut. The key milestones for this goal are as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[x] MVP implementation&lt;/li&gt;
&lt;li&gt;[x] Case study evaluations complete&lt;/li&gt;
&lt;li&gt;[ ] Accepted RFC for return-position impl trait (target: 2023-05-31)&lt;/li&gt;
&lt;li&gt;[ ] Accepted RFC for associated return types (target: 2023-06-15)&lt;/li&gt;
&lt;li&gt;[ ] Evaluation period and bug fixing (target: 2023-06-30)&lt;/li&gt;
&lt;li&gt;[ ] Stabilization report authored (target: 2023-07-01)&lt;/li&gt;
&lt;li&gt;[ ] Stabilization complete for 1.74.0 (target: 2023-07-21)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can find the &lt;a href&#x3D;&quot;https://github.com/orgs/rust-lang/projects/28/views/2&quot;&gt;complete timeline in our github project&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-comes-next&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-comes-next&quot;&gt;&lt;/a&gt;What comes next?&lt;/h2&gt;
&lt;p&gt;So, once this MVP is done, what next? Our next immediate goals are to ship &lt;strong&gt;dynamic dispatch&lt;/strong&gt; and &lt;strong&gt;async closures&lt;/strong&gt; support in 2024. Together this will complete a solid foundation to tackle future async problems, such as support for async drop, easy async iterators, or portability across runtimes.&lt;/p&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;If &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/41517&quot;&gt;RFC 1733&lt;/a&gt; were stabilized, this would be easier. &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Niko Matsakis and Tyler Mandry</name>
        </author>
    </entry>
    
    <entry>
        <title>Postmortem Analysis in Cargo</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/05/01/cargo-postmortem.html" type="text/html" title="Postmortem Analysis in Cargo" />
        <published>2023-05-01T00:00:00+00:00</published>
        <updated>2023-05-01T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/05/01/cargo-postmortem.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/05/01/cargo-postmortem.html">&lt;p&gt;At 01:52 UTC, 2022-10-28, &lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/pull/11183&quot;&gt;rust-lang/cargo#11183&lt;/a&gt; was merged into the Cargo master branch. It introduced a bug that caused Cargo to fail to build packages that use a particular, but very common, dependency setup. The change nearly made its way into the next nightly release. If it had, it would have rendered any of the 30k crates with &lt;code&gt;serde_derive&lt;/code&gt; as a dependency (one of the most popular crate on crates.io) unbuildable for anyone using the resulting nightly release.&lt;/p&gt;
&lt;p&gt;Following this incident, the Cargo team went through a postmortem analysis, as is appropriate for incidents with (a potential for) broad blast-radius or otherwise significant impact. This time around, we followed a particular structured postmortem template in the hopes that it might make the resulting write-up more thorough, insightful, and actionable, and we ultimately found that it gave us a better understanding of the underlying root causes and failing/missing safe-guards. So, we wanted to share our experience with other Rust teams in case they may find it similarly useful, either in part or as a whole.&lt;/p&gt;
&lt;p&gt;The postmortem template consists of four parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;What happened:&lt;/strong&gt; a summary that provides context for the event, including metrics or graphs that illustrate the impact of the event if available. This should include a summary of any user-facing impacts or experience during the event.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;How we responded:&lt;/strong&gt; a timeline that describes all the events that occurred during the incident including specific date/time to the extent that they are known, as well as answers to the following four questions:
&lt;ul&gt;
&lt;li&gt;How was the event detected?&lt;/li&gt;
&lt;li&gt;How could time to detection be improved?&lt;/li&gt;
&lt;li&gt;How did you reach the point where you knew how to mitigate the impact?&lt;/li&gt;
&lt;li&gt;How could time to mitigation be improved?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Why the event happened:&lt;/strong&gt; this is the juicy part. Here, we use the &lt;a href&#x3D;&quot;https://en.wikipedia.org/wiki/Five_whys&quot;&gt;Five Whys&lt;/a&gt; approach to dig deeply down until the incident’s root causes are identified. Each answer is meant to spawn one or more why questions, until you’re confident that the left answers are fundamentally root causes. It’s also worth pointing out explicitly that “operator error” is &lt;strong&gt;never&lt;/strong&gt; a root cause, and that this is not a process for assigning blame. Instead, any operator error is a symptom of a missing or broken mechanism, and the answers should focus on identifying those inadequate mechanisms.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;How to fix it:&lt;/strong&gt; The outcome of the Five Whys exercise is a list of root causes that should be addressed to reduce the risk of a similar incident in the future. From these root causes, we produce short- and medium-term “action items” along with specific owners wherever possible. Long-term solutions can be discussed too, although the focus of action items should be on more immediate mitigation steps that will be taken relatively soon. Each action item is assigned a priority, and is then generally turned into a GitHub issue where applicable. Any items identified as urgent we start working on immediately, while other action items usually fall into the categories “soon” or “once feasible”.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Note: to ensure the focus stays on mechanisms and processes, not individuals, individuals should not be named unless absolutely necessary. Use terms like &amp;quot;a contributor&amp;quot;, &amp;quot;the maintainer&amp;quot;, &amp;quot;a libs team member&amp;quot;, etc.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;So, without further ado, here is &lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/issues/12064&quot;&gt;the postmortem for the aforementioned Cargo incident&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Jon Gjengset and Weihang Lo</name>
        </author>
    </entry>
    
    <entry>
        <title>1.69.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/04/17/1.69.0-prerelease.html" type="text/html" title="1.69.0 pre-release testing" />
        <published>2023-04-17T00:00:00+00:00</published>
        <updated>2023-04-17T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/04/17/1.69.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/04/17/1.69.0-prerelease.html">&lt;p&gt;The 1.69.0 pre-release is ready for testing. The release is scheduled for
April 20. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1690-2023-04-20&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2023-04-17/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2023-04-17/index.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-69-0-pre-release-testing/18692&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The release team is also thinking about changes to our pre-release process:
we&#x27;d love your feedback &lt;a href&#x3D;&quot;https://github.com/rust-lang/release-team/issues/16&quot;&gt;on this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Release automation</name>
        </author>
    </entry>
    
    <entry>
        <title>A note on the Trademark Policy Draft</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/04/12/trademark-policy-draft-feedback.html" type="text/html" title="A note on the Trademark Policy Draft" />
        <published>2023-04-12T00:00:00+00:00</published>
        <updated>2023-04-12T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/04/12/trademark-policy-draft-feedback.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/04/12/trademark-policy-draft-feedback.html">&lt;h1&gt;&lt;a href&#x3D;&quot;#a-note-on-the-trademark-policy-draft&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;a-note-on-the-trademark-policy-draft&quot;&gt;&lt;/a&gt;A note on the Trademark Policy Draft&lt;/h1&gt;
&lt;p&gt;For the past eight months, the Rust Foundation Project Directors have been working with the informal Trademark Working Group and the Foundation staff to draft an updated policy and FAQ for the Rust trademark. We&#x27;d like to provide some context around this work and address the community response to the &lt;a href&#x3D;&quot;https://docs.google.com/forms/d/e/1FAIpQLSdaM4pdWFsLJ8GHIUFIhepuq0lfTg_b0mJ-hvwPdHa4UTRaAg/viewform&quot;&gt;feedback form&lt;/a&gt; for the recently circulated draft.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#background&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;
&lt;p&gt;Back when the Rust Foundation was created, one of the first things to happen was Mozilla transferring its ownership of the Rust trademark to the newly created foundation. An update to the &lt;a href&#x3D;&quot;http://web.archive.org/web/20230407100922/https://foundation.rust-lang.org/policies/logo-policy-and-media-guide/&quot;&gt;existing policy&lt;/a&gt; was needed, and project leadership planned for this to be done together with the Foundation.&lt;/p&gt;
&lt;p&gt;Since we wanted to incorporate community input to this policy and make it accessible as possible, the board waited until the Foundation was well-staffed to coordinate the effort. That included things like running a &lt;a href&#x3D;&quot;https://foundation.rust-lang.org/news/2022-08-09-trademark-policy-review-and-survey/&quot;&gt;community-wide survey&lt;/a&gt; and discussing the result with a number of stakeholders, including the board, community members, project leadership, as well as legal counsel. The latest state of this process is the draft that was published late last week.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#our-approach&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;our-approach&quot;&gt;&lt;/a&gt;Our approach&lt;/h2&gt;
&lt;p&gt;Since the draft was announced, we&#x27;ve noticed a widespread impression that this policy was created solely by the Foundation and is being imposed on the Rust Project and community. That is not true. The policy draft was created with the input and consent of each of the co-authors of this post, with the intent to clarify existing policies, incorporate community feedback, and preserve the Rust brand for years to come. The Foundation also cannot – and has no interest in – unilaterally adopting such a policy without the agreement and involvement of its Project Directors.&lt;/p&gt;
&lt;p&gt;There can be wildly differing opinions on how to achieve a particular intent.&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; Fundamentally however, the question at hand is whether we want Rust to be a trademark or not. If we want to be able to defend Rust as the brand it is today, trademark law fundamentally constrains how permissible we can be, especially in public guidelines.&lt;/p&gt;
&lt;p&gt;Our answer to the question of whether Rust should be a trademark has been &amp;quot;yes&amp;quot;, just as it has been since before Rust 1.0. Furthermore, our goal is to make a policy that is as permissive as it can be without substantially giving up our right to define what Rust &lt;em&gt;is&lt;/em&gt; and &lt;em&gt;is not&lt;/em&gt; in the future. Not all open source projects have retained that right.&lt;/p&gt;
&lt;p&gt;We aren&#x27;t lawyers and we leave the question of &lt;em&gt;how&lt;/em&gt; to do that to them – and believe us when we say we have gone through &lt;em&gt;many&lt;/em&gt; rounds of questions with ours, who have extensive experience in open source projects.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#feedback&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;feedback&quot;&gt;&lt;/a&gt;Feedback&lt;/h2&gt;
&lt;p&gt;The current proposal is a draft that the Foundation staff, Project Directors, and Trademark Working Group are actively seeking feedback on. We will not ship a trademark policy that Project representatives and the Foundation aren&#x27;t happy with and proud of after reviewing community feedback.&lt;/p&gt;
&lt;p&gt;We genuinely appreciate all the thoughtful input the community has already left, both in public and via the &lt;a href&#x3D;&quot;https://docs.google.com/forms/d/e/1FAIpQLSdaM4pdWFsLJ8GHIUFIhepuq0lfTg_b0mJ-hvwPdHa4UTRaAg/viewform&quot;&gt;feedback form&lt;/a&gt;.&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn2&quot; id&#x3D;&quot;fnref2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; Please continue to utilize this form as the official way of getting feedback back into this process. We know the draft is not perfect, and we&#x27;re committed to fixing any mistakes identified and considering the feedback we get.&lt;/p&gt;
&lt;p&gt;Unfortunately, in addition to the large volume of thoughtful and respectful feedback, we&#x27;re ashamed to say we&#x27;ve seen firsthand examples of significant harassment and abuse directed at the Foundation staff. &lt;strong&gt;We condemn this in the strongest possible terms.&lt;/strong&gt; These folks have been doing their best to navigate an extremely diverse set of interests and viewpoints throughout this process. It&#x27;s unacceptable for anyone in the Rust community to demean, harass or insult anyone, let alone the people we&#x27;ve asked to do this work.&lt;/p&gt;
&lt;p&gt;Please remember that any and all communication with Foundation staff is subject to the Rust project &lt;a href&#x3D;&quot;https://www.rust-lang.org/policies/code-of-conduct&quot;&gt;Code of Conduct&lt;/a&gt; and will be enforced accordingly. We don&#x27;t expect this to be an issue for most people participating, but when emotions run high it&#x27;s always a good idea to check your assumptions and remember the person on the other end of the keyboard.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#next-steps&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;next-steps&quot;&gt;&lt;/a&gt;Next steps&lt;/h2&gt;
&lt;p&gt;We want to thank the community for participating in this process, and for your patience as we learn the best way to navigate it. We recognize that the process and communication around it could have been better. Notably, the wider project was insufficiently included in the process. We were  responsible for that and apologize.&lt;/p&gt;
&lt;p&gt;We&#x27;re committed to learning everything we can from this process and your feedback, and to talking as openly as we can about what we&#x27;ve learned. To that end, we will soon conduct and publish a retrospective around how the process unfolded.&lt;/p&gt;
&lt;p&gt;Thank you again to those who have shared their thoughts on the Rust Trademark Policy draft respectfully. A summary of the feedback received will be shared after the consultation period closes. If you have not yet reviewed the draft, we invite you to fill out the &lt;a href&#x3D;&quot;https://docs.google.com/forms/d/e/1FAIpQLSdaM4pdWFsLJ8GHIUFIhepuq0lfTg_b0mJ-hvwPdHa4UTRaAg/viewform&quot;&gt;feedback form&lt;/a&gt; by April 16 at 5 PM PDT. We only ask that you treat everyone in this community, including the Rust Foundation team, respectfully when doing so.&lt;/p&gt;
&lt;p&gt;Sincerely,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ryan Levick, Project Director and trademark working group member&lt;/li&gt;
&lt;li&gt;Jane Losare-Lusby, Project Director&lt;/li&gt;
&lt;li&gt;Tyler Mandry, Project Director&lt;/li&gt;
&lt;li&gt;Mark Rousskov, Project Director&lt;/li&gt;
&lt;li&gt;Josh Stone, Project Director and trademark working group member&lt;/li&gt;
&lt;li&gt;Josh Triplett, Lang team lead and trademark working group member&lt;/li&gt;
&lt;/ul&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;This was none more apparent than when the community survey got over 1,000 responses, representing a number of popular but fundamentally incompatible views. &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn2&quot;&gt;
&lt;p&gt;We know this feedback-via-form exercise is not familiar, and we&#x27;re still getting used to it, too. But it&#x27;s really the best we can do when we&#x27;re asking a heroic staff to read and respond to the feedback, and when it&#x27;s a legal matter where what we say can have substantial consequences down the line. &lt;a href&#x3D;&quot;#fnref2&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Ryan Levick, Jane Losare-Lusby, Tyler Mandry, Mark Rousskov, Josh Stone, and Josh Triplett</name>
        </author>
    </entry>
    
    <entry>
        <title>Welcome Arlo and Scott to the Cargo Team</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/04/06/cargo-new-members.html" type="text/html" title="Welcome Arlo and Scott to the Cargo Team" />
        <published>2023-04-06T00:00:00+00:00</published>
        <updated>2023-04-06T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/04/06/cargo-new-members.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/04/06/cargo-new-members.html">&lt;p&gt;We are excited to welcome &lt;a href&#x3D;&quot;https://github.com/arlosi&quot;&gt;Arlo Siemsen&lt;/a&gt; and &lt;a href&#x3D;&quot;https://github.com/Muscraft&quot;&gt;Scott Schafer&lt;/a&gt; as new members to the Cargo Team!&lt;/p&gt;
&lt;p&gt;Arlo has been instrumental in bringing Cargo&#x27;s new &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2023/01/30/cargo-sparse-protocol.html&quot;&gt;sparse registry&lt;/a&gt; support to fruition, which significantly improves registry performance. He has been involved with registry design and authentication discussions, and has been closely working with the team over the past year.&lt;/p&gt;
&lt;p&gt;Scott has been very active in the past year, working on various parts of Cargo, namely implementing &lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/workspaces.html#the-package-table&quot;&gt;workspace inheritance&lt;/a&gt;. Since then, he has been helping with maintenance and designing new features.&lt;/p&gt;
&lt;p&gt;With their help we now have capacity to start thinking about how feature development should be done moving forward. We are still in early discussions of processes for matching feature development with reviewer capacity, and will share more in the future. Thanks to Arlo and Scott for their help, and we are very much looking forward to having them as a part of the team!&lt;/p&gt;
</content>

        <author>
            <name>Eric Huss</name>
        </author>
    </entry>
    
    <entry>
        <title>1.68.2 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/03/27/1.68.2-prerelease.html" type="text/html" title="1.68.2 pre-release testing" />
        <published>2023-03-27T00:00:00+00:00</published>
        <updated>2023-03-27T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/03/27/1.68.2-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/03/27/1.68.2-prerelease.html">&lt;p&gt;The 1.68.2 pre-release is ready for testing. The release is scheduled for
March 28. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1682-2023-03-28&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2023-03-27/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2023-03-27/index.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-68-2-pre-release-testing/18585&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The release team is also thinking about changes to our pre-release process:
we&#x27;d love your feedback &lt;a href&#x3D;&quot;https://github.com/rust-lang/release-team/issues/16&quot;&gt;on this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Release automation</name>
        </author>
    </entry>
    
    <entry>
        <title>1.68.1 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/03/20/1.68.1-prerelease.html" type="text/html" title="1.68.1 pre-release testing" />
        <published>2023-03-20T00:00:00+00:00</published>
        <updated>2023-03-20T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/03/20/1.68.1-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/03/20/1.68.1-prerelease.html">&lt;p&gt;The 1.68.1 pre-release is ready for testing. The release is scheduled for
March 23. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1681-2023-03-23&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2023-03-20/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2023-03-20/index.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-68-1-pre-release-testing/18547&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The release team is also thinking about changes to our pre-release process:
we&#x27;d love your feedback &lt;a href&#x3D;&quot;https://github.com/rust-lang/release-team/issues/16&quot;&gt;on this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Release automation</name>
        </author>
    </entry>
    
    <entry>
        <title>1.68.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/03/06/1.68.0-prerelease.html" type="text/html" title="1.68.0 pre-release testing" />
        <published>2023-03-06T00:00:00+00:00</published>
        <updated>2023-03-06T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/03/06/1.68.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/03/06/1.68.0-prerelease.html">&lt;p&gt;The 1.68.0 pre-release is ready for testing. The release is scheduled for
March 09. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1680-2023-03-09&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2023-03-06/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2023-03-06/index.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-68-0-pre-release-testing/18481&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The release team is also thinking about changes to our pre-release process:
we&#x27;d love your feedback &lt;a href&#x3D;&quot;https://github.com/rust-lang/release-team/issues/16&quot;&gt;on this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Release automation</name>
        </author>
    </entry>
    
</feed>
